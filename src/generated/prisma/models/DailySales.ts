
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `DailySales` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model DailySales
 * 
 */
export type DailySalesModel = runtime.Types.Result.DefaultSelection<Prisma.$DailySalesPayload>

export type AggregateDailySales = {
  _count: DailySalesCountAggregateOutputType | null
  _avg: DailySalesAvgAggregateOutputType | null
  _sum: DailySalesSumAggregateOutputType | null
  _min: DailySalesMinAggregateOutputType | null
  _max: DailySalesMaxAggregateOutputType | null
}

export type DailySalesAvgAggregateOutputType = {
  totalOrders: number | null
  totalRevenue: number | null
  deliveryOrders: number | null
  pickupOrders: number | null
  cancelledOrders: number | null
  averageOrderValue: number | null
}

export type DailySalesSumAggregateOutputType = {
  totalOrders: number | null
  totalRevenue: number | null
  deliveryOrders: number | null
  pickupOrders: number | null
  cancelledOrders: number | null
  averageOrderValue: number | null
}

export type DailySalesMinAggregateOutputType = {
  id: string | null
  date: Date | null
  totalOrders: number | null
  totalRevenue: number | null
  deliveryOrders: number | null
  pickupOrders: number | null
  cancelledOrders: number | null
  averageOrderValue: number | null
}

export type DailySalesMaxAggregateOutputType = {
  id: string | null
  date: Date | null
  totalOrders: number | null
  totalRevenue: number | null
  deliveryOrders: number | null
  pickupOrders: number | null
  cancelledOrders: number | null
  averageOrderValue: number | null
}

export type DailySalesCountAggregateOutputType = {
  id: number
  date: number
  totalOrders: number
  totalRevenue: number
  deliveryOrders: number
  pickupOrders: number
  cancelledOrders: number
  averageOrderValue: number
  _all: number
}


export type DailySalesAvgAggregateInputType = {
  totalOrders?: true
  totalRevenue?: true
  deliveryOrders?: true
  pickupOrders?: true
  cancelledOrders?: true
  averageOrderValue?: true
}

export type DailySalesSumAggregateInputType = {
  totalOrders?: true
  totalRevenue?: true
  deliveryOrders?: true
  pickupOrders?: true
  cancelledOrders?: true
  averageOrderValue?: true
}

export type DailySalesMinAggregateInputType = {
  id?: true
  date?: true
  totalOrders?: true
  totalRevenue?: true
  deliveryOrders?: true
  pickupOrders?: true
  cancelledOrders?: true
  averageOrderValue?: true
}

export type DailySalesMaxAggregateInputType = {
  id?: true
  date?: true
  totalOrders?: true
  totalRevenue?: true
  deliveryOrders?: true
  pickupOrders?: true
  cancelledOrders?: true
  averageOrderValue?: true
}

export type DailySalesCountAggregateInputType = {
  id?: true
  date?: true
  totalOrders?: true
  totalRevenue?: true
  deliveryOrders?: true
  pickupOrders?: true
  cancelledOrders?: true
  averageOrderValue?: true
  _all?: true
}

export type DailySalesAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which DailySales to aggregate.
   */
  where?: Prisma.DailySalesWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailySales to fetch.
   */
  orderBy?: Prisma.DailySalesOrderByWithRelationInput | Prisma.DailySalesOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.DailySalesWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailySales from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailySales.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned DailySales
  **/
  _count?: true | DailySalesCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: DailySalesAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: DailySalesSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: DailySalesMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: DailySalesMaxAggregateInputType
}

export type GetDailySalesAggregateType<T extends DailySalesAggregateArgs> = {
      [P in keyof T & keyof AggregateDailySales]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateDailySales[P]>
    : Prisma.GetScalarType<T[P], AggregateDailySales[P]>
}




export type DailySalesGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.DailySalesWhereInput
  orderBy?: Prisma.DailySalesOrderByWithAggregationInput | Prisma.DailySalesOrderByWithAggregationInput[]
  by: Prisma.DailySalesScalarFieldEnum[] | Prisma.DailySalesScalarFieldEnum
  having?: Prisma.DailySalesScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: DailySalesCountAggregateInputType | true
  _avg?: DailySalesAvgAggregateInputType
  _sum?: DailySalesSumAggregateInputType
  _min?: DailySalesMinAggregateInputType
  _max?: DailySalesMaxAggregateInputType
}

export type DailySalesGroupByOutputType = {
  id: string
  date: Date
  totalOrders: number
  totalRevenue: number
  deliveryOrders: number
  pickupOrders: number
  cancelledOrders: number
  averageOrderValue: number
  _count: DailySalesCountAggregateOutputType | null
  _avg: DailySalesAvgAggregateOutputType | null
  _sum: DailySalesSumAggregateOutputType | null
  _min: DailySalesMinAggregateOutputType | null
  _max: DailySalesMaxAggregateOutputType | null
}

type GetDailySalesGroupByPayload<T extends DailySalesGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<DailySalesGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof DailySalesGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], DailySalesGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], DailySalesGroupByOutputType[P]>
      }
    >
  >



export type DailySalesWhereInput = {
  AND?: Prisma.DailySalesWhereInput | Prisma.DailySalesWhereInput[]
  OR?: Prisma.DailySalesWhereInput[]
  NOT?: Prisma.DailySalesWhereInput | Prisma.DailySalesWhereInput[]
  id?: Prisma.StringFilter<"DailySales"> | string
  date?: Prisma.DateTimeFilter<"DailySales"> | Date | string
  totalOrders?: Prisma.IntFilter<"DailySales"> | number
  totalRevenue?: Prisma.IntFilter<"DailySales"> | number
  deliveryOrders?: Prisma.IntFilter<"DailySales"> | number
  pickupOrders?: Prisma.IntFilter<"DailySales"> | number
  cancelledOrders?: Prisma.IntFilter<"DailySales"> | number
  averageOrderValue?: Prisma.IntFilter<"DailySales"> | number
}

export type DailySalesOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  totalOrders?: Prisma.SortOrder
  totalRevenue?: Prisma.SortOrder
  deliveryOrders?: Prisma.SortOrder
  pickupOrders?: Prisma.SortOrder
  cancelledOrders?: Prisma.SortOrder
  averageOrderValue?: Prisma.SortOrder
}

export type DailySalesWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  date?: Date | string
  AND?: Prisma.DailySalesWhereInput | Prisma.DailySalesWhereInput[]
  OR?: Prisma.DailySalesWhereInput[]
  NOT?: Prisma.DailySalesWhereInput | Prisma.DailySalesWhereInput[]
  totalOrders?: Prisma.IntFilter<"DailySales"> | number
  totalRevenue?: Prisma.IntFilter<"DailySales"> | number
  deliveryOrders?: Prisma.IntFilter<"DailySales"> | number
  pickupOrders?: Prisma.IntFilter<"DailySales"> | number
  cancelledOrders?: Prisma.IntFilter<"DailySales"> | number
  averageOrderValue?: Prisma.IntFilter<"DailySales"> | number
}, "id" | "date">

export type DailySalesOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  totalOrders?: Prisma.SortOrder
  totalRevenue?: Prisma.SortOrder
  deliveryOrders?: Prisma.SortOrder
  pickupOrders?: Prisma.SortOrder
  cancelledOrders?: Prisma.SortOrder
  averageOrderValue?: Prisma.SortOrder
  _count?: Prisma.DailySalesCountOrderByAggregateInput
  _avg?: Prisma.DailySalesAvgOrderByAggregateInput
  _max?: Prisma.DailySalesMaxOrderByAggregateInput
  _min?: Prisma.DailySalesMinOrderByAggregateInput
  _sum?: Prisma.DailySalesSumOrderByAggregateInput
}

export type DailySalesScalarWhereWithAggregatesInput = {
  AND?: Prisma.DailySalesScalarWhereWithAggregatesInput | Prisma.DailySalesScalarWhereWithAggregatesInput[]
  OR?: Prisma.DailySalesScalarWhereWithAggregatesInput[]
  NOT?: Prisma.DailySalesScalarWhereWithAggregatesInput | Prisma.DailySalesScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"DailySales"> | string
  date?: Prisma.DateTimeWithAggregatesFilter<"DailySales"> | Date | string
  totalOrders?: Prisma.IntWithAggregatesFilter<"DailySales"> | number
  totalRevenue?: Prisma.IntWithAggregatesFilter<"DailySales"> | number
  deliveryOrders?: Prisma.IntWithAggregatesFilter<"DailySales"> | number
  pickupOrders?: Prisma.IntWithAggregatesFilter<"DailySales"> | number
  cancelledOrders?: Prisma.IntWithAggregatesFilter<"DailySales"> | number
  averageOrderValue?: Prisma.IntWithAggregatesFilter<"DailySales"> | number
}

export type DailySalesCreateInput = {
  id?: string
  date: Date | string
  totalOrders?: number
  totalRevenue?: number
  deliveryOrders?: number
  pickupOrders?: number
  cancelledOrders?: number
  averageOrderValue?: number
}

export type DailySalesUncheckedCreateInput = {
  id?: string
  date: Date | string
  totalOrders?: number
  totalRevenue?: number
  deliveryOrders?: number
  pickupOrders?: number
  cancelledOrders?: number
  averageOrderValue?: number
}

export type DailySalesUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  totalOrders?: Prisma.IntFieldUpdateOperationsInput | number
  totalRevenue?: Prisma.IntFieldUpdateOperationsInput | number
  deliveryOrders?: Prisma.IntFieldUpdateOperationsInput | number
  pickupOrders?: Prisma.IntFieldUpdateOperationsInput | number
  cancelledOrders?: Prisma.IntFieldUpdateOperationsInput | number
  averageOrderValue?: Prisma.IntFieldUpdateOperationsInput | number
}

export type DailySalesUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  totalOrders?: Prisma.IntFieldUpdateOperationsInput | number
  totalRevenue?: Prisma.IntFieldUpdateOperationsInput | number
  deliveryOrders?: Prisma.IntFieldUpdateOperationsInput | number
  pickupOrders?: Prisma.IntFieldUpdateOperationsInput | number
  cancelledOrders?: Prisma.IntFieldUpdateOperationsInput | number
  averageOrderValue?: Prisma.IntFieldUpdateOperationsInput | number
}

export type DailySalesCreateManyInput = {
  id?: string
  date: Date | string
  totalOrders?: number
  totalRevenue?: number
  deliveryOrders?: number
  pickupOrders?: number
  cancelledOrders?: number
  averageOrderValue?: number
}

export type DailySalesUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  totalOrders?: Prisma.IntFieldUpdateOperationsInput | number
  totalRevenue?: Prisma.IntFieldUpdateOperationsInput | number
  deliveryOrders?: Prisma.IntFieldUpdateOperationsInput | number
  pickupOrders?: Prisma.IntFieldUpdateOperationsInput | number
  cancelledOrders?: Prisma.IntFieldUpdateOperationsInput | number
  averageOrderValue?: Prisma.IntFieldUpdateOperationsInput | number
}

export type DailySalesUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  totalOrders?: Prisma.IntFieldUpdateOperationsInput | number
  totalRevenue?: Prisma.IntFieldUpdateOperationsInput | number
  deliveryOrders?: Prisma.IntFieldUpdateOperationsInput | number
  pickupOrders?: Prisma.IntFieldUpdateOperationsInput | number
  cancelledOrders?: Prisma.IntFieldUpdateOperationsInput | number
  averageOrderValue?: Prisma.IntFieldUpdateOperationsInput | number
}

export type DailySalesCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  totalOrders?: Prisma.SortOrder
  totalRevenue?: Prisma.SortOrder
  deliveryOrders?: Prisma.SortOrder
  pickupOrders?: Prisma.SortOrder
  cancelledOrders?: Prisma.SortOrder
  averageOrderValue?: Prisma.SortOrder
}

export type DailySalesAvgOrderByAggregateInput = {
  totalOrders?: Prisma.SortOrder
  totalRevenue?: Prisma.SortOrder
  deliveryOrders?: Prisma.SortOrder
  pickupOrders?: Prisma.SortOrder
  cancelledOrders?: Prisma.SortOrder
  averageOrderValue?: Prisma.SortOrder
}

export type DailySalesMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  totalOrders?: Prisma.SortOrder
  totalRevenue?: Prisma.SortOrder
  deliveryOrders?: Prisma.SortOrder
  pickupOrders?: Prisma.SortOrder
  cancelledOrders?: Prisma.SortOrder
  averageOrderValue?: Prisma.SortOrder
}

export type DailySalesMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  totalOrders?: Prisma.SortOrder
  totalRevenue?: Prisma.SortOrder
  deliveryOrders?: Prisma.SortOrder
  pickupOrders?: Prisma.SortOrder
  cancelledOrders?: Prisma.SortOrder
  averageOrderValue?: Prisma.SortOrder
}

export type DailySalesSumOrderByAggregateInput = {
  totalOrders?: Prisma.SortOrder
  totalRevenue?: Prisma.SortOrder
  deliveryOrders?: Prisma.SortOrder
  pickupOrders?: Prisma.SortOrder
  cancelledOrders?: Prisma.SortOrder
  averageOrderValue?: Prisma.SortOrder
}



export type DailySalesSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  date?: boolean
  totalOrders?: boolean
  totalRevenue?: boolean
  deliveryOrders?: boolean
  pickupOrders?: boolean
  cancelledOrders?: boolean
  averageOrderValue?: boolean
}, ExtArgs["result"]["dailySales"]>

export type DailySalesSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  date?: boolean
  totalOrders?: boolean
  totalRevenue?: boolean
  deliveryOrders?: boolean
  pickupOrders?: boolean
  cancelledOrders?: boolean
  averageOrderValue?: boolean
}, ExtArgs["result"]["dailySales"]>

export type DailySalesSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  date?: boolean
  totalOrders?: boolean
  totalRevenue?: boolean
  deliveryOrders?: boolean
  pickupOrders?: boolean
  cancelledOrders?: boolean
  averageOrderValue?: boolean
}, ExtArgs["result"]["dailySales"]>

export type DailySalesSelectScalar = {
  id?: boolean
  date?: boolean
  totalOrders?: boolean
  totalRevenue?: boolean
  deliveryOrders?: boolean
  pickupOrders?: boolean
  cancelledOrders?: boolean
  averageOrderValue?: boolean
}

export type DailySalesOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "date" | "totalOrders" | "totalRevenue" | "deliveryOrders" | "pickupOrders" | "cancelledOrders" | "averageOrderValue", ExtArgs["result"]["dailySales"]>

export type $DailySalesPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "DailySales"
  objects: {}
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    date: Date
    totalOrders: number
    totalRevenue: number
    deliveryOrders: number
    pickupOrders: number
    cancelledOrders: number
    averageOrderValue: number
  }, ExtArgs["result"]["dailySales"]>
  composites: {}
}

export type DailySalesGetPayload<S extends boolean | null | undefined | DailySalesDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$DailySalesPayload, S>

export type DailySalesCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<DailySalesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DailySalesCountAggregateInputType | true
  }

export interface DailySalesDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailySales'], meta: { name: 'DailySales' } }
  /**
   * Find zero or one DailySales that matches the filter.
   * @param {DailySalesFindUniqueArgs} args - Arguments to find a DailySales
   * @example
   * // Get one DailySales
   * const dailySales = await prisma.dailySales.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends DailySalesFindUniqueArgs>(args: Prisma.SelectSubset<T, DailySalesFindUniqueArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one DailySales that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {DailySalesFindUniqueOrThrowArgs} args - Arguments to find a DailySales
   * @example
   * // Get one DailySales
   * const dailySales = await prisma.dailySales.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends DailySalesFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, DailySalesFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first DailySales that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailySalesFindFirstArgs} args - Arguments to find a DailySales
   * @example
   * // Get one DailySales
   * const dailySales = await prisma.dailySales.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends DailySalesFindFirstArgs>(args?: Prisma.SelectSubset<T, DailySalesFindFirstArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first DailySales that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailySalesFindFirstOrThrowArgs} args - Arguments to find a DailySales
   * @example
   * // Get one DailySales
   * const dailySales = await prisma.dailySales.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends DailySalesFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, DailySalesFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more DailySales that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailySalesFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all DailySales
   * const dailySales = await prisma.dailySales.findMany()
   * 
   * // Get first 10 DailySales
   * const dailySales = await prisma.dailySales.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const dailySalesWithIdOnly = await prisma.dailySales.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends DailySalesFindManyArgs>(args?: Prisma.SelectSubset<T, DailySalesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a DailySales.
   * @param {DailySalesCreateArgs} args - Arguments to create a DailySales.
   * @example
   * // Create one DailySales
   * const DailySales = await prisma.dailySales.create({
   *   data: {
   *     // ... data to create a DailySales
   *   }
   * })
   * 
   */
  create<T extends DailySalesCreateArgs>(args: Prisma.SelectSubset<T, DailySalesCreateArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many DailySales.
   * @param {DailySalesCreateManyArgs} args - Arguments to create many DailySales.
   * @example
   * // Create many DailySales
   * const dailySales = await prisma.dailySales.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends DailySalesCreateManyArgs>(args?: Prisma.SelectSubset<T, DailySalesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many DailySales and returns the data saved in the database.
   * @param {DailySalesCreateManyAndReturnArgs} args - Arguments to create many DailySales.
   * @example
   * // Create many DailySales
   * const dailySales = await prisma.dailySales.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many DailySales and only return the `id`
   * const dailySalesWithIdOnly = await prisma.dailySales.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends DailySalesCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, DailySalesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a DailySales.
   * @param {DailySalesDeleteArgs} args - Arguments to delete one DailySales.
   * @example
   * // Delete one DailySales
   * const DailySales = await prisma.dailySales.delete({
   *   where: {
   *     // ... filter to delete one DailySales
   *   }
   * })
   * 
   */
  delete<T extends DailySalesDeleteArgs>(args: Prisma.SelectSubset<T, DailySalesDeleteArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one DailySales.
   * @param {DailySalesUpdateArgs} args - Arguments to update one DailySales.
   * @example
   * // Update one DailySales
   * const dailySales = await prisma.dailySales.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends DailySalesUpdateArgs>(args: Prisma.SelectSubset<T, DailySalesUpdateArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more DailySales.
   * @param {DailySalesDeleteManyArgs} args - Arguments to filter DailySales to delete.
   * @example
   * // Delete a few DailySales
   * const { count } = await prisma.dailySales.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends DailySalesDeleteManyArgs>(args?: Prisma.SelectSubset<T, DailySalesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more DailySales.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailySalesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many DailySales
   * const dailySales = await prisma.dailySales.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends DailySalesUpdateManyArgs>(args: Prisma.SelectSubset<T, DailySalesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more DailySales and returns the data updated in the database.
   * @param {DailySalesUpdateManyAndReturnArgs} args - Arguments to update many DailySales.
   * @example
   * // Update many DailySales
   * const dailySales = await prisma.dailySales.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more DailySales and only return the `id`
   * const dailySalesWithIdOnly = await prisma.dailySales.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends DailySalesUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, DailySalesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one DailySales.
   * @param {DailySalesUpsertArgs} args - Arguments to update or create a DailySales.
   * @example
   * // Update or create a DailySales
   * const dailySales = await prisma.dailySales.upsert({
   *   create: {
   *     // ... data to create a DailySales
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the DailySales we want to update
   *   }
   * })
   */
  upsert<T extends DailySalesUpsertArgs>(args: Prisma.SelectSubset<T, DailySalesUpsertArgs<ExtArgs>>): Prisma.Prisma__DailySalesClient<runtime.Types.Result.GetResult<Prisma.$DailySalesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of DailySales.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailySalesCountArgs} args - Arguments to filter DailySales to count.
   * @example
   * // Count the number of DailySales
   * const count = await prisma.dailySales.count({
   *   where: {
   *     // ... the filter for the DailySales we want to count
   *   }
   * })
  **/
  count<T extends DailySalesCountArgs>(
    args?: Prisma.Subset<T, DailySalesCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], DailySalesCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a DailySales.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailySalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends DailySalesAggregateArgs>(args: Prisma.Subset<T, DailySalesAggregateArgs>): Prisma.PrismaPromise<GetDailySalesAggregateType<T>>

  /**
   * Group by DailySales.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailySalesGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends DailySalesGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: DailySalesGroupByArgs['orderBy'] }
      : { orderBy?: DailySalesGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, DailySalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailySalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the DailySales model
 */
readonly fields: DailySalesFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for DailySales.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__DailySalesClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the DailySales model
 */
export interface DailySalesFieldRefs {
  readonly id: Prisma.FieldRef<"DailySales", 'String'>
  readonly date: Prisma.FieldRef<"DailySales", 'DateTime'>
  readonly totalOrders: Prisma.FieldRef<"DailySales", 'Int'>
  readonly totalRevenue: Prisma.FieldRef<"DailySales", 'Int'>
  readonly deliveryOrders: Prisma.FieldRef<"DailySales", 'Int'>
  readonly pickupOrders: Prisma.FieldRef<"DailySales", 'Int'>
  readonly cancelledOrders: Prisma.FieldRef<"DailySales", 'Int'>
  readonly averageOrderValue: Prisma.FieldRef<"DailySales", 'Int'>
}
    

// Custom InputTypes
/**
 * DailySales findUnique
 */
export type DailySalesFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * Filter, which DailySales to fetch.
   */
  where: Prisma.DailySalesWhereUniqueInput
}

/**
 * DailySales findUniqueOrThrow
 */
export type DailySalesFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * Filter, which DailySales to fetch.
   */
  where: Prisma.DailySalesWhereUniqueInput
}

/**
 * DailySales findFirst
 */
export type DailySalesFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * Filter, which DailySales to fetch.
   */
  where?: Prisma.DailySalesWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailySales to fetch.
   */
  orderBy?: Prisma.DailySalesOrderByWithRelationInput | Prisma.DailySalesOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for DailySales.
   */
  cursor?: Prisma.DailySalesWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailySales from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailySales.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of DailySales.
   */
  distinct?: Prisma.DailySalesScalarFieldEnum | Prisma.DailySalesScalarFieldEnum[]
}

/**
 * DailySales findFirstOrThrow
 */
export type DailySalesFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * Filter, which DailySales to fetch.
   */
  where?: Prisma.DailySalesWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailySales to fetch.
   */
  orderBy?: Prisma.DailySalesOrderByWithRelationInput | Prisma.DailySalesOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for DailySales.
   */
  cursor?: Prisma.DailySalesWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailySales from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailySales.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of DailySales.
   */
  distinct?: Prisma.DailySalesScalarFieldEnum | Prisma.DailySalesScalarFieldEnum[]
}

/**
 * DailySales findMany
 */
export type DailySalesFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * Filter, which DailySales to fetch.
   */
  where?: Prisma.DailySalesWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailySales to fetch.
   */
  orderBy?: Prisma.DailySalesOrderByWithRelationInput | Prisma.DailySalesOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing DailySales.
   */
  cursor?: Prisma.DailySalesWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailySales from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailySales.
   */
  skip?: number
  distinct?: Prisma.DailySalesScalarFieldEnum | Prisma.DailySalesScalarFieldEnum[]
}

/**
 * DailySales create
 */
export type DailySalesCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * The data needed to create a DailySales.
   */
  data: Prisma.XOR<Prisma.DailySalesCreateInput, Prisma.DailySalesUncheckedCreateInput>
}

/**
 * DailySales createMany
 */
export type DailySalesCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many DailySales.
   */
  data: Prisma.DailySalesCreateManyInput | Prisma.DailySalesCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * DailySales createManyAndReturn
 */
export type DailySalesCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * The data used to create many DailySales.
   */
  data: Prisma.DailySalesCreateManyInput | Prisma.DailySalesCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * DailySales update
 */
export type DailySalesUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * The data needed to update a DailySales.
   */
  data: Prisma.XOR<Prisma.DailySalesUpdateInput, Prisma.DailySalesUncheckedUpdateInput>
  /**
   * Choose, which DailySales to update.
   */
  where: Prisma.DailySalesWhereUniqueInput
}

/**
 * DailySales updateMany
 */
export type DailySalesUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update DailySales.
   */
  data: Prisma.XOR<Prisma.DailySalesUpdateManyMutationInput, Prisma.DailySalesUncheckedUpdateManyInput>
  /**
   * Filter which DailySales to update
   */
  where?: Prisma.DailySalesWhereInput
  /**
   * Limit how many DailySales to update.
   */
  limit?: number
}

/**
 * DailySales updateManyAndReturn
 */
export type DailySalesUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * The data used to update DailySales.
   */
  data: Prisma.XOR<Prisma.DailySalesUpdateManyMutationInput, Prisma.DailySalesUncheckedUpdateManyInput>
  /**
   * Filter which DailySales to update
   */
  where?: Prisma.DailySalesWhereInput
  /**
   * Limit how many DailySales to update.
   */
  limit?: number
}

/**
 * DailySales upsert
 */
export type DailySalesUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * The filter to search for the DailySales to update in case it exists.
   */
  where: Prisma.DailySalesWhereUniqueInput
  /**
   * In case the DailySales found by the `where` argument doesn't exist, create a new DailySales with this data.
   */
  create: Prisma.XOR<Prisma.DailySalesCreateInput, Prisma.DailySalesUncheckedCreateInput>
  /**
   * In case the DailySales was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.DailySalesUpdateInput, Prisma.DailySalesUncheckedUpdateInput>
}

/**
 * DailySales delete
 */
export type DailySalesDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
  /**
   * Filter which DailySales to delete.
   */
  where: Prisma.DailySalesWhereUniqueInput
}

/**
 * DailySales deleteMany
 */
export type DailySalesDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which DailySales to delete
   */
  where?: Prisma.DailySalesWhereInput
  /**
   * Limit how many DailySales to delete.
   */
  limit?: number
}

/**
 * DailySales without action
 */
export type DailySalesDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailySales
   */
  select?: Prisma.DailySalesSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailySales
   */
  omit?: Prisma.DailySalesOmit<ExtArgs> | null
}
